#Kevin BÃœrger

Mermaid Chart:
https://www.mermaidchart.com/app/projects/bb353608-c047-464b-9d51-2d40f317cc1c/diagrams/cd9c7c7e-f5b9-438e-8294-6ff0333b3f35/version/v0.1/edit

Klasse	    Zweck

Vehicle	    Interface: einheitliche Struktur fÃ¼r Fahrzeuge (z.â€¯B. UGV)
UGV	        Konkretes   Fahrzeug (mit Batterie, Position, Aufgabenliste)
Position	Value Object: Darstellung geografischer Koordinaten
Task	    Eine Aufgabe, die ein Fahrzeug erledigen soll (besteht aus Routen)
Route	    Eine geplante Strecke (besteht aus mehreren Positionen)


-------------------------------------------------------------------------------------------

ğŸ”Œ Vehicle â€“ das Interface

public interface Vehicle {
    String getId();
    Position getCurrentPosition();
    void assignTask(Task task);
}

Warum wichtig?
â†’ Damit du spÃ¤ter auch andere Fahrzeugtypen (z.â€¯B. Drohnen) einbauen kannst.
â†’ Mit dem Interface kannst du polymorph arbeiten, z.â€¯B.:

List<Vehicle> allVehicles = ... // Kann UGVs oder andere enthalten

Nutzen: klare Trennung von was ein Fahrzeug tun soll vs. wie es es tut.

------------------------------------------------------------------------------------------

ğŸ“Œ Position â€“ das Value Object

public class Position {
    private final double latitude;
    private final double longitude;
    ...
}

Warum wichtig?
â†’ Jede Route und jedes Fahrzeug hat eine Position. Du brauchst diese Klasse, um z.â€¯B. zu berechnen, wie weit Fahrzeuge voneinander entfernt sind.

Warum final?
â†’ Es ist unverÃ¤nderlich, also ein echtes Value Object (wie im Video erwÃ¤hnt). Das vermeidet Seiteneffekte.

-------------------------------------------------------------------------------------------

ğŸš— UGV â€“ das konkrete Fahrzeug

public class UGV implements Vehicle {
    private final String id;
    private Position currentPosition;
    private double batteryLevel;
    private List<Task> tasks = new ArrayList<>();
    ...
}

Was ist drin?

    id: eindeutige Kennung

    currentPosition: wo es gerade ist

    batteryLevel: wie viel Saft noch drin ist âš¡

    tasks: Liste aller zugewiesenen Aufgaben

Warum wichtig?
â†’ Das ist die zentrale Klasse, die alles "lebt": bekommt Aufgaben, fÃ¤hrt Strecken usw.

-------------------------------------------------------------------------------------------

ğŸ“‹ Task â€“ eine zugewiesene Aufgabe

public class Task {
    private final String taskId;
    private final List<Route> routes;
}

Was ist drin?

    taskId: eindeutige Kennung

    routes: eine Aufgabe besteht aus mehreren Routen, z.â€¯B.:

        Lager A â†’ Ãœbergabepunkt

        Ãœbergabepunkt â†’ Lager B

Warum wichtig?
â†’ Macht die Aufgaben flexibel: ein Fahrzeug kann mehrere Strecken in einem Auftrag fahren.

-------------------------------------------------------------------------------------------

ğŸ—ºï¸ Route â€“ eine Strecke

public class Route {
    private final String routeId;
    private final List<Position> waypoints;
}

Was ist drin?

    routeId: Name/ID der Route

    waypoints: einzelne GPS-Punkte, die das Fahrzeug abfahren soll

Warum wichtig?
â†’ ErmÃ¶glicht dir spÃ¤ter sogar eine Art Navigation oder Visualisierung auf einer Karte.
â†’ Damit kannst du z.â€¯B. auch Routen vergleichen oder neu planen lassen.

-------------------------------------------------------------------------------------------

ğŸ”® Was spÃ¤ter noch kommen kann (aber noch nicht muss)

Zusatzklasse	Zweck

FleetManager	Zentrale Verwaltung der Flotte
DiagnosticTool	Batteriezustand, Fehler usw.
RoutePlanner	Planung & Umplanung von Routen
User / Admin	Authentifizierung (Sicherheit)
REST-API	    Kommunikation mit UGVs

-------------------------------------------------------------------------------------------

ğŸ¯ Fazit

Mit den 5 Klassen, die du jetzt hast, kannst du:

    Fahrzeuge erstellen und verwalten

    Aufgaben und Routen definieren

    Schnittstellen und Vererbung nutzen

    Prinzipien wie Value Object & Entkopplung verstehen

-------------------------------------------------------------------------------------------